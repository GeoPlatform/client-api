import NodeHttpClient from '../../http/node';
import { Config, ItemService } from '@geoplatform/client';
const GP_AUTH_COOKIE = 'gpoauth-a';
const ɵ0 = function (router, routes, options) {
    console.log(" ");
    console.log("BINDING ROUTES!");
    console.log(" ");
    options = options || {};
    let paths = options.paths || {};
    let auths = options.auth || {};
    routes.forEach(route => {
        if (paths[route.key] === false)
            return; //disabled endpoint
        if (!paths[route.key] && !route.path)
            return; //something is wrong with route
        //newer route override...
        // {
        //   'create': {
        //     'path': 'custom/path',
        //     'auth': true,
        //     'onResponse': function(result, res, next) { }
        //   }
        // }
        let overrides = options[route.key] || {};
        //look for overriden paths in either new override structure or older key:path format
        let path = '/' + (overrides.path || paths[route.key] || route.path);
        //look for authentication override in either new structure or older format
        let needsAuth = overrides.auth || auths[route.key] || route.auth;
        if (options.logger) {
            options.logger.debug(`Binding Service Route [${route.method}] ${path}`);
        }
        router[route.method](path, (req, res, next) => {
            let promise = null;
            if (typeof (route.onExecute) !== 'function') {
                promise = Promise.resolve(null);
            }
            else {
                if (options.logger) {
                    options.logger.debug(`Executing Service Route [${route.method}] ${path}`);
                    options.logger.debug(JSON.stringify(req.params));
                    options.logger.debug("-------------------------");
                }
                let svc = this.getService(req, needsAuth, options);
                try {
                    promise = route.onExecute(svc, req);
                }
                catch (e) {
                    promise = Promise.reject(e);
                }
            }
            promise.then((result) => {
                let onResponse = overrides.onResponse || route.onResponse;
                if (onResponse)
                    onResponse(result, res, next);
                else
                    res.json(result);
            })
                .catch((err) => {
                if (overrides.onError)
                    overrides.onError(err);
                if (options.onError)
                    options.onError(route.key, err);
                next(err);
            })
                .finally(() => {
                //if route has a finish function defined, invoke it
                if (overrides.onFinish) {
                    overrides.onFinish(req, res);
                }
                //if proxy has an overall finish function defined, invoke it
                let finishFn = options.onFinish;
                if (finishFn)
                    finishFn(route.key, req, res);
            });
        });
    });
}, ɵ1 = function (req, needsAuth, options) {
    let token = req.accessToken || null;
    if (needsAuth && options && options.logger) {
        if (!token) {
            options.logger.warn("ServiceProxy.getClient() - No Access Token was provided on incoming request header!");
        }
        else if (!!options.debug) {
            options.logger.debug(`ServiceProxy.getClient() - Token: ${token}`);
            options.logger.debug(`ServiceProxy.getClient() - JWT: ${req.jwt}`);
        }
    }
    //check the incoming proxied request for cookies that should be forwarded along
    let cookie = this.getAuthCookie(req);
    // console.log("COOKIE IS " + cookie);
    if (cookie && !cookie.length)
        cookie = null;
    // if(options && options.logger) {
    //     options.logger.debug("Proxying Request Cookie: " + cookie);
    //     options.logger.debug(" ");
    // } else {
    //     console.log("Proxying Request Cookie: " + cookie);
    // }
    return new NodeHttpClient({
        timeout: Config.timeout,
        token: needsAuth ? token : null,
        cookie: needsAuth ? cookie : null
    });
}, ɵ2 = function (req, needsAuth, options) {
    let client = this.getClient(req, needsAuth, options);
    let svcClass = options.serviceClass || ItemService;
    // console.log("Proxying to " + Config.ualUrl);
    if (options.logger) {
        options.logger.debug(`Proxying to ${Config.ualUrl}`);
        // options.logger.debug("Using service class: " + svcClass);
    }
    let service = new svcClass(Config.ualUrl, client);
    service.setTimeout(Config.timeout || 30000);
    if (options.logger) {
        service.setLogger(options.logger);
    }
    return service;
}, ɵ3 = function (req) {
    if (!req)
        return null;
    if (req.cookies) { //parsed by cookieParser already
        // console.log("COOKIES PARSED ... ");
        // console.log("COOKIES ARE...");
        // console.log(JSON.stringify(req.cookies));
        // console.log(" ");
        // console.log("AUTH COOKIE IS " + req.cookies[GP_AUTH_COOKIE]);
        return req.cookies[GP_AUTH_COOKIE];
    }
    else if (req.headers.cookie) {
        // console.log("COOKIES NEED PARSING");
        try {
            let cookies = this.parseCookies(req.headers.cookie);
            return cookies[GP_AUTH_COOKIE];
        }
        catch (e) {
            console.log("ERROR parsing cookies: " + e.message);
            return null;
        }
    }
}, ɵ4 = function parse(str) {
    if (!str || typeof str !== 'string' || !str.length)
        return null;
    let result = {};
    let expr = /; */;
    let pairs = str.split(expr);
    pairs.forEach(pair => {
        let sepIdx = pair.indexOf('=');
        if (sepIdx < 0)
            return; //ignore non- 'key=value' values
        let key = pair.substr(0, sepIdx).trim();
        let val = pair.substr(++sepIdx, pair.length).trim();
        // quoted values
        if ('"' == val[0])
            val = val.slice(1, -1);
        // only assign once
        if (undefined == result[key]) {
            let value = val;
            try {
                value = decodeURIComponent(val);
            }
            catch (e) { }
            result[key] = value;
        }
    });
    return result;
};
const ServiceProxy = {
    /**
     * @param {Router} router - ExpressJS router instance
     * @param {array[object]} routes - list of routes to map to the router
     * @param {object} options - additional configuration needed
     */
    bindRoutes: ɵ0,
    /**
    * @param {HttpRequest} req - incoming http request being proxied
    * @param {boolean} needsAuth - flag indicating if the request must provide an authentication token
    * @param {object} options - additional configuration options
    * @return {HttpClient} client to use to make requests to GeoPlatform API endpoint
    */
    getClient: ɵ1,
    /**
     * @param {HttpRequest} req - incoming http request being proxied
     * @param {boolean} needsAuth - flag indicating if request requires authorization token
     * @param {object} options - additional configuration options
     */
    getService: ɵ2,
    getAuthCookie: ɵ3,
    parseCookies: ɵ4
};
export default ServiceProxy;
export { ɵ0, ɵ1, ɵ2, ɵ3, ɵ4 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BnZW9wbGF0Zm9ybS9jbGllbnQvbm9kZS8iLCJzb3VyY2VzIjpbInNlcnZpY2VzL3Byb3hpZXMvYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLGNBQWMsTUFBTSxpQkFBaUIsQ0FBQztBQUM3QyxPQUFPLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRTFELE1BQU0sY0FBYyxHQUFHLFdBQVcsQ0FBQztXQVNuQixVQUFTLE1BQVksRUFBRSxNQUFjLEVBQUUsT0FBYztJQUU3RCxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUMvQixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBSWpCLE9BQU8sR0FBRyxPQUFPLElBQUksRUFBRSxDQUFDO0lBQ3hCLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDO0lBQ2hDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO0lBRS9CLE1BQU0sQ0FBQyxPQUFPLENBQUUsS0FBSyxDQUFDLEVBQUU7UUFFcEIsSUFBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEtBQUs7WUFBRSxPQUFPLENBQUUsbUJBQW1CO1FBQzNELElBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUk7WUFBRSxPQUFPLENBQUMsK0JBQStCO1FBRTVFLHlCQUF5QjtRQUN6QixJQUFJO1FBQ0osZ0JBQWdCO1FBQ2hCLDZCQUE2QjtRQUM3QixvQkFBb0I7UUFDcEIsb0RBQW9EO1FBQ3BELE1BQU07UUFDTixJQUFJO1FBQ0osSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFH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UUFFMUMsbUJBQW1CO1FBQ25CLElBQUksU0FBUyxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMxQixJQUFJLEtBQUssR0FBRyxHQUFHLENBQUM7WUFDaEIsSUFBSTtnQkFDQSxLQUFLLEdBQUcsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDbkM7WUFBQyxPQUFPLENBQUMsRUFBRSxHQUFHO1lBQ2YsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUN2QjtJQUNMLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQztBQXRNTCxNQUFNLFlBQVksR0FBRztJQUVqQjs7OztPQUlHO0lBQ0gsVUFBVSxJQStFVDtJQUVEOzs7OztNQUtFO0lBQ0YsU0FBUyxJQThCUjtJQUdEOzs7O09BSUc7SUFDSCxVQUFVLElBY1Q7SUFFRCxhQUFhLElBbUJaO0lBRUQsWUFBWSxJQTZCWDtDQUtKLENBQUM7QUFFRixlQUFlLFlBQVksQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG5pbXBvcnQgTm9kZUh0dHBDbGllbnQgZnJvbSAnLi4vLi4vaHR0cC9ub2RlJztcbmltcG9ydCB7IENvbmZpZywgSXRlbVNlcnZpY2UgfSBmcm9tICdAZ2VvcGxhdGZvcm0vY2xpZW50JztcblxuY29uc3QgR1BfQVVUSF9DT09LSUUgPSAnZ3BvYXV0aC1hJztcblxuY29uc3QgU2VydmljZVByb3h5ID0ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSb3V0ZXJ9IHJvdXRlciAtIEV4cHJlc3NKUyByb3V0ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge2FycmF5W29iamVjdF19IHJvdXRlcyAtIGxpc3Qgb2Ygcm91dGVzIHRvIG1hcCB0byB0aGUgcm91dGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gbmVlZGVkXG4gICAgICovXG4gICAgYmluZFJvdXRlczogZnVuY3Rpb24ocm91dGVyIDogYW55LCByb3V0ZXMgOiBhbnlbXSwgb3B0aW9ucyA/OiBhbnkpIHtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIiBcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQklORElORyBST1VURVMhXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIiBcIik7XG5cblxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgcGF0aHMgPSBvcHRpb25zLnBhdGhzIHx8IHt9O1xuICAgICAgICBsZXQgYXV0aHMgPSBvcHRpb25zLmF1dGggfHwge307XG5cbiAgICAgICAgcm91dGVzLmZvckVhY2goIHJvdXRlID0+IHtcblxuICAgICAgICAgICAgaWYocGF0aHNbcm91dGUua2V5XSA9PT0gZmFsc2UpIHJldHVybjsgIC8vZGlzYWJsZWQgZW5kcG9pbnRcbiAgICAgICAgICAgIGlmKCFwYXRoc1tyb3V0ZS5rZXldICYmICFyb3V0ZS5wYXRoKSByZXR1cm47IC8vc29tZXRoaW5nIGlzIHdyb25nIHdpdGggcm91dGVcblxuICAgICAgICAgICAgLy9uZXdlciByb3V0ZSBvdmVycmlkZS4uLlxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gICAnY3JlYXRlJzoge1xuICAgICAgICAgICAgLy8gICAgICdwYXRoJzogJ2N1c3RvbS9wYXRoJyxcbiAgICAgICAgICAgIC8vICAgICAnYXV0aCc6IHRydWUsXG4gICAgICAgICAgICAvLyAgICAgJ29uUmVzcG9uc2UnOiBmdW5jdGlvbihyZXN1bHQsIHJlcywgbmV4dCkgeyB9XG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGxldCBvdmVycmlkZXMgPSBvcHRpb25zW3JvdXRlLmtleV0gfHwge307XG5cbiAgICAgICAgICAgIC8vbG9vayBmb3Igb3ZlcnJpZGVuIHBhdGhzIGluIGVpdGhlciBuZXcgb3ZlcnJpZGUgc3RydWN0dXJlIG9yIG9sZGVyIGtleTpwYXRoIGZvcm1hdFxuICAgICAgICAgICAgbGV0IHBhdGggPSAnLycgKyAoIG92ZXJyaWRlcy5wYXRoIHx8IHBhdGhzW3JvdXRlLmtleV0gfHwgcm91dGUucGF0aCApO1xuICAgICAgICAgICAgLy9sb29rIGZvciBhdXRoZW50aWNhdGlvbiBvdmVycmlkZSBpbiBlaXRoZXIgbmV3IHN0cnVjdHVyZSBvciBvbGRlciBmb3JtYXRcbiAgICAgICAgICAgIGxldCBuZWVkc0F1dGggPSBvdmVycmlkZXMuYXV0aCB8fCBhdXRoc1tyb3V0ZS5rZXldIHx8IHJvdXRlLmF1dGg7XG5cbiAgICAgICAgICAgIGlmKG9wdGlvbnMubG9nZ2VyKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2dnZXIuZGVidWcoYEJpbmRpbmcgU2VydmljZSBSb3V0ZSBbJHtyb3V0ZS5tZXRob2R9XSAke3BhdGh9YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdXRlcltyb3V0ZS5tZXRob2RdKCBwYXRoLCAocmVxIDogYW55LCByZXMgOiBhbnksIG5leHQgOiBGdW5jdGlvbikgPT4ge1xuXG4gICAgICAgICAgICAgICAgbGV0IHByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZihyb3V0ZS5vbkV4ZWN1dGUpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoIG51bGwgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZihvcHRpb25zLmxvZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2dnZXIuZGVidWcoYEV4ZWN1dGluZyBTZXJ2aWNlIFJvdXRlIFske3JvdXRlLm1ldGhvZH1dICR7cGF0aH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2dnZXIuZGVidWcoSlNPTi5zdHJpbmdpZnkocmVxLnBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2dnZXIuZGVidWcoXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdmMgPSB0aGlzLmdldFNlcnZpY2UocmVxLCBuZWVkc0F1dGgsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gcm91dGUub25FeGVjdXRlKHN2YywgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbiggKCByZXN1bHQgOiBhbnkgKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvblJlc3BvbnNlID0gb3ZlcnJpZGVzLm9uUmVzcG9uc2UgfHwgcm91dGUub25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgaWYob25SZXNwb25zZSkgb25SZXNwb25zZShyZXN1bHQsIHJlcywgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmVzLmpzb24ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCggKGVyciA6IEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKG92ZXJyaWRlcy5vbkVycm9yKSBvdmVycmlkZXMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICBpZihvcHRpb25zLm9uRXJyb3IpIG9wdGlvbnMub25FcnJvcihyb3V0ZS5rZXksIGVycik7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoZXJyKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiByb3V0ZSBoYXMgYSBmaW5pc2ggZnVuY3Rpb24gZGVmaW5lZCwgaW52b2tlIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmKG92ZXJyaWRlcy5vbkZpbmlzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzLm9uRmluaXNoKHJlcSwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgcHJveHkgaGFzIGFuIG92ZXJhbGwgZmluaXNoIGZ1bmN0aW9uIGRlZmluZWQsIGludm9rZSBpdFxuICAgICAgICAgICAgICAgICAgICBsZXQgZmluaXNoRm4gPSBvcHRpb25zLm9uRmluaXNoO1xuICAgICAgICAgICAgICAgICAgICBpZihmaW5pc2hGbikgZmluaXNoRm4ocm91dGUua2V5LCByZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIGluY29taW5nIGh0dHAgcmVxdWVzdCBiZWluZyBwcm94aWVkXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5lZWRzQXV0aCAtIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgcmVxdWVzdCBtdXN0IHByb3ZpZGUgYW4gYXV0aGVudGljYXRpb24gdG9rZW5cbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAqIEByZXR1cm4ge0h0dHBDbGllbnR9IGNsaWVudCB0byB1c2UgdG8gbWFrZSByZXF1ZXN0cyB0byBHZW9QbGF0Zm9ybSBBUEkgZW5kcG9pbnRcbiAgICAqL1xuICAgIGdldENsaWVudDogZnVuY3Rpb24ocmVxIDogYW55LCBuZWVkc0F1dGggOiBib29sZWFuLCBvcHRpb25zID86IGFueSkge1xuXG4gICAgICAgIGxldCB0b2tlbiA9IHJlcS5hY2Nlc3NUb2tlbiB8fCBudWxsO1xuICAgICAgICBpZihuZWVkc0F1dGggJiYgb3B0aW9ucyAmJiBvcHRpb25zLmxvZ2dlcikge1xuICAgICAgICAgICAgaWYoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2dnZXIud2FybihcIlNlcnZpY2VQcm94eS5nZXRDbGllbnQoKSAtIE5vIEFjY2VzcyBUb2tlbiB3YXMgcHJvdmlkZWQgb24gaW5jb21pbmcgcmVxdWVzdCBoZWFkZXIhXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCEhb3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nZ2VyLmRlYnVnKGBTZXJ2aWNlUHJveHkuZ2V0Q2xpZW50KCkgLSBUb2tlbjogJHt0b2tlbn1gKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvZ2dlci5kZWJ1ZyhgU2VydmljZVByb3h5LmdldENsaWVudCgpIC0gSldUOiAke3JlcS5qd3R9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIHRoZSBpbmNvbWluZyBwcm94aWVkIHJlcXVlc3QgZm9yIGNvb2tpZXMgdGhhdCBzaG91bGQgYmUgZm9yd2FyZGVkIGFsb25nXG4gICAgICAgIGxldCBjb29raWUgPSB0aGlzLmdldEF1dGhDb29raWUocmVxKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJDT09LSUUgSVMgXCIgKyBjb29raWUpO1xuICAgICAgICBpZihjb29raWUgJiYgIWNvb2tpZS5sZW5ndGgpIGNvb2tpZSA9IG51bGw7XG5cbiAgICAgICAgLy8gaWYob3B0aW9ucyAmJiBvcHRpb25zLmxvZ2dlcikge1xuICAgICAgICAvLyAgICAgb3B0aW9ucy5sb2dnZXIuZGVidWcoXCJQcm94eWluZyBSZXF1ZXN0IENvb2tpZTogXCIgKyBjb29raWUpO1xuICAgICAgICAvLyAgICAgb3B0aW9ucy5sb2dnZXIuZGVidWcoXCIgXCIpO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJQcm94eWluZyBSZXF1ZXN0IENvb2tpZTogXCIgKyBjb29raWUpO1xuICAgICAgICAvLyB9XG5cblxuICAgICAgICByZXR1cm4gbmV3IE5vZGVIdHRwQ2xpZW50KHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IENvbmZpZy50aW1lb3V0LFxuICAgICAgICAgICAgdG9rZW46IG5lZWRzQXV0aCA/IHRva2VuIDogbnVsbCxcbiAgICAgICAgICAgIGNvb2tpZTogbmVlZHNBdXRoID8gY29va2llIDogbnVsbFxuICAgICAgICB9KTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h0dHBSZXF1ZXN0fSByZXEgLSBpbmNvbWluZyBodHRwIHJlcXVlc3QgYmVpbmcgcHJveGllZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVlZHNBdXRoIC0gZmxhZyBpbmRpY2F0aW5nIGlmIHJlcXVlc3QgcmVxdWlyZXMgYXV0aG9yaXphdGlvbiB0b2tlblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlOiBmdW5jdGlvbihyZXEgOiBhbnksIG5lZWRzQXV0aCA6IGJvb2xlYW4sIG9wdGlvbnMgPzogYW55KSB7XG4gICAgICAgIGxldCBjbGllbnQgPSB0aGlzLmdldENsaWVudChyZXEsIG5lZWRzQXV0aCwgb3B0aW9ucyk7XG4gICAgICAgIGxldCBzdmNDbGFzcyA9IG9wdGlvbnMuc2VydmljZUNsYXNzIHx8IEl0ZW1TZXJ2aWNlO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlByb3h5aW5nIHRvIFwiICsgQ29uZmlnLnVhbFVybCk7XG4gICAgICAgIGlmKG9wdGlvbnMubG9nZ2VyKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxvZ2dlci5kZWJ1ZyhgUHJveHlpbmcgdG8gJHtDb25maWcudWFsVXJsfWApO1xuICAgICAgICAgICAgLy8gb3B0aW9ucy5sb2dnZXIuZGVidWcoXCJVc2luZyBzZXJ2aWNlIGNsYXNzOiBcIiArIHN2Y0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VydmljZSA9IG5ldyBzdmNDbGFzcyhDb25maWcudWFsVXJsLCBjbGllbnQpO1xuICAgICAgICBzZXJ2aWNlLnNldFRpbWVvdXQoQ29uZmlnLnRpbWVvdXQgfHwgMzAwMDApO1xuICAgICAgICBpZihvcHRpb25zLmxvZ2dlcikge1xuICAgICAgICAgICAgc2VydmljZS5zZXRMb2dnZXIob3B0aW9ucy5sb2dnZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgIH0sXG5cbiAgICBnZXRBdXRoQ29va2llOiBmdW5jdGlvbihyZXE6IGFueSkgOiBzdHJpbmcge1xuICAgICAgICBpZighcmVxKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYocmVxLmNvb2tpZXMpIHsgICAvL3BhcnNlZCBieSBjb29raWVQYXJzZXIgYWxyZWFkeVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJDT09LSUVTIFBBUlNFRCAuLi4gXCIpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJDT09LSUVTIEFSRS4uLlwiKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHJlcS5jb29raWVzKSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiBcIik7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkFVVEggQ09PS0lFIElTIFwiICsgcmVxLmNvb2tpZXNbR1BfQVVUSF9DT09LSUVdKTtcbiAgICAgICAgICAgIHJldHVybiByZXEuY29va2llc1tHUF9BVVRIX0NPT0tJRV07XG4gICAgICAgIH0gZWxzZSBpZihyZXEuaGVhZGVycy5jb29raWUpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQ09PS0lFUyBORUVEIFBBUlNJTkdcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBjb29raWVzID0gdGhpcy5wYXJzZUNvb2tpZXMocmVxLmhlYWRlcnMuY29va2llKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29va2llc1tHUF9BVVRIX0NPT0tJRV07XG4gICAgICAgICAgICB9IGNhdGNoKCBlICkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1IgcGFyc2luZyBjb29raWVzOiBcIiArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFyc2VDb29raWVzOiBmdW5jdGlvbiBwYXJzZShzdHIgOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgdHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgIXN0ci5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGxldCByZXN1bHQgPSB7fVxuICAgICAgICBsZXQgZXhwciA9IC87ICovO1xuICAgICAgICBsZXQgcGFpcnMgPSBzdHIuc3BsaXQoZXhwcik7XG5cbiAgICAgICAgcGFpcnMuZm9yRWFjaCggcGFpciA9PiB7XG4gICAgICAgICAgICBsZXQgc2VwSWR4ID0gcGFpci5pbmRleE9mKCc9Jyk7XG5cbiAgICAgICAgICAgIGlmIChzZXBJZHggPCAwKSByZXR1cm47IC8vaWdub3JlIG5vbi0gJ2tleT12YWx1ZScgdmFsdWVzXG5cbiAgICAgICAgICAgIGxldCBrZXkgPSBwYWlyLnN1YnN0cigwLCBzZXBJZHgpLnRyaW0oKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBwYWlyLnN1YnN0cigrK3NlcElkeCwgcGFpci5sZW5ndGgpLnRyaW0oKTtcblxuICAgICAgICAgICAgLy8gcXVvdGVkIHZhbHVlc1xuICAgICAgICAgICAgaWYgKCdcIicgPT0gdmFsWzBdKSB2YWwgPSB2YWwuc2xpY2UoMSwgLTEpO1xuXG4gICAgICAgICAgICAvLyBvbmx5IGFzc2lnbiBvbmNlXG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09IHJlc3VsdFtrZXldKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxuXG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNlcnZpY2VQcm94eTtcbiJdfQ==